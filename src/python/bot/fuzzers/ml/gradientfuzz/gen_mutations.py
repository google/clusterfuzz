# Copyright 2020 Google Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
################################################################################
"""libFuzzer Neural Smoothing - Mutation Generation."""

import glob
import json
import math
import os
import sys
import threading

import numpy as np
import tqdm

import bot.fuzzers.ml.gradientfuzz.constants as constants
import bot.fuzzers.ml.gradientfuzz.libfuzzer_to_numpy as libfuzzer_to_numpy
import bot.fuzzers.ml.gradientfuzz.opts as opts


def write_numpy_to_bytefile(numpy_out, output_file_path):
  """
    Writes numpy byte array to specified output file. Sanity-checked
    with Linux diff tool.

    Args:
        numpy_out (np.ndarray): Array of bytes (entries in range 0-255) to be
            dumped.
        output_file_path (str): Full file path to save byte dump to.

    Returns:
        N/A
    """
  bytes_out = bytes(list(numpy_out))
  with open(output_file_path, 'wb') as output_file:
    output_file.write(bytes_out)


def extract_ranges(mut_range_idx, critical_indices, seed_file_numpy):
  """
    Extracts the appropriate mutation range based on the current
    `mut_range_idx`, and the corresponding indices and bytes to be
    mutated.

    Args:
        mut_range_idx (int): Determines start/end indices for critical
            locations to mutate.
        critical_indices (np.ndarray): Indices generated by
            `gradient_gen_critical_locs.py` at which to mutate.
        seed_file_numpy (np.ndarray): Numpy array of raw input bytes.

    Returns:
        mut_range (list): Range of critical location indices at which to mutate.
        considered_indices (np.ndarray): Indices at which to mutate.
        considered_bytes (np.ndarray): Current input byte values at
            `considered_indices`.
    """
  mut_range = list(
      range(constants.NEUZZ_MUT_IDX_RANGES[mut_range_idx],
            constants.NEUZZ_MUT_IDX_RANGES[mut_range_idx + 1]))
  considered_indices = critical_indices[mut_range]
  considered_bytes = seed_file_numpy[considered_indices]

  return mut_range, considered_indices, considered_bytes


def get_signs_and_limits(mut_range, considered_bytes):
  """
    Grabs a random vector of signs in {-1, +1}^{len(mut_range)}
    to repeatedly add to `considered_indices`, and returns the min
    number of iterations needed in either direction to completely
    saturate all bytes in `considered_bytes`.

    Args:
        mut_range (list): Range of critical location indices at which to mutate.

    Returns:
        signs (np.ndarrray): Vector in {-1, +1}^{len(mut_range)} which
            gets repeatedly added/subtracted from `considered_bytes` until
            saturation.
        positive_iter_limit (int): Minimum number of times `signs` must be
            added to `considered_bytes` to saturate.
        negative_iter_limit (int): Minimum number of times `signs` must be
            subtracted from `considered_bytes` to saturate.
    """

  # {Add, Subtract} until we get to {255, 0} for each byte considered.
  signs = np.random.choice([-1, 1], size=len(mut_range), replace=True)
  positive_limits = np.asarray([(constants.MAX_BYTE_VAL
                                 if x == 1 else constants.MIN_BYTE_VAL)
                                for x in signs])
  negative_limits = constants.MAX_BYTE_VAL - positive_limits

  # How many times we have to iterate \pm 1 until all considered bytes
  # are saturated (i.e. either 0 or 255).
  positive_iter_limit = np.max(np.abs(positive_limits - considered_bytes))
  negative_iter_limit = np.max(np.abs(negative_limits - considered_bytes))

  return signs, positive_iter_limit, negative_iter_limit


def perform_neuzz_mutation(seed_file_numpy, mut_range, branch_idx, iter_limit,
                           considered_indices, mutations_dir, seed_file_name,
                           signs, positive):
  """
    Makes a copy of `seed_file_numpy` and adds/subtracts `signs`
    to seed_file[considered_indices] for `iter_limit` iterations,
    i.e. until saturated. Saves each mutation to a separate file.

    Args:
        seed_file_numpy (np.ndarray): Numpy array of raw input bytes.
        mut_range (list): Range of critical location indices at which to mutate.
        branch_idx (int): Which output branch gradients were taken
            with respect to.
        iter_limit (int): Minimum number of times `signs` must be added/
            subtracted to saturate.
        considered_indices (np.ndarray): Indices at which to mutate.
        mutations_dir (str): Directory to write mutated files to.
        seed_file_name (str): Basename (no extension) of the seed file
            being mutated.
        signs (np.ndarray): Vector in {-1, +1}^{len(mut_range)} which
            gets repeatedly added/subtracted from seed_file[considered_indices]
            until saturation.
        positive (bool): Whether to add or subtract `signs`.

    Returns:
        N/A (saves mutated outputs to generated/[generation-name]/mutations).
    """
  actual_signs = signs if positive else -1 * signs
  mutation_prefix = (
      constants.PLUS_MUTATION_PREFIX
      if positive else constants.MINUS_MUTATION_PREFIX)
  seed_file_copy = seed_file_numpy.copy()

  # Iterate until saturated. Add `actual_signs` and save to appropriate path.
  for plus_iter in range(iter_limit):
    seed_file_copy[considered_indices] += actual_signs
    seed_file_copy[considered_indices] = np.clip(
        seed_file_copy[considered_indices],
        a_max=constants.MAX_BYTE_VAL,
        a_min=constants.MIN_BYTE_VAL)
    save_path = (
        os.path.join(mutations_dir, mutation_prefix + seed_file_name).format(
            branch_idx=branch_idx, start=mut_range[0], num=plus_iter))
    write_numpy_to_bytefile(seed_file_copy, save_path)


def mutate_one_like_neuzz(seed_file_numpy, ordered_indices, mutations_dir,
                          seed_file_name):
  """
    Mutates a single seed file. Emulates mutations performed in
    https://github.com/Dongdongshe/neuzz/blob/2c7179557a491266ca1478e5f8c431d0b69d3e3a/neuzz.c#L1155.

    In particular, for each seed file, for each range of critical locations
    (as specified by constants.NEUZZ_MUT_IDX_RANGES), the following happens:
        > Find the critical locations within the seed file.
        > Generate a random sign {-1, +1} for each critical location.
        > Until all critical bytes (i.e. bytes at critical locations) are
            saturated (i.e. either 0 or 255), add sign[location] to each
            critical byte, and save resulting byte array as a mutated output.

    Args:
        seed_file_numpy (np.ndarray): Numpy array version of the
            seed file's bytes.
        ordered_indices (np.ndarray): Numpy array containing rows of critical
            locs, ordered by their respective gradient component magnitudes.
        mutations_dir (str): Directory to write mutated files to.
        seed_file_name (str): Raw basename (no extension) of the
            seed file to be mutated.


    Returns:
        N/A (mutated files are saved under
            generated/[generation-name]/mutations)
    """
  for idx, critical_indices in enumerate(ordered_indices):
    for mut_range_idx in range(len(constants.NEUZZ_MUT_IDX_RANGES) - 1):

      # Extract mutation ranges, get subset of critical bytes/locations,
      # and generate mutations until all are saturated.
      mut_range, considered_indices, considered_bytes = extract_ranges(
          mut_range_idx, critical_indices, seed_file_numpy)
      signs, positive_iter_limit, negative_iter_limit = get_signs_and_limits(
          mut_range, considered_bytes)
      perform_neuzz_mutation(seed_file_numpy, mut_range, idx,
                             positive_iter_limit, considered_indices,
                             mutations_dir, seed_file_name, signs, True)
      perform_neuzz_mutation(seed_file_numpy, mut_range, idx,
                             negative_iter_limit, considered_indices,
                             mutations_dir, seed_file_name, signs, False)


def mutate_one_limited_neighborhood(
    seed_file_numpy, ordered_indices, mutations_dir, seed_file_name,
    num_mutations, neighborhood_max_width, arith_min, arith_max):
  """
    Generates mutations by picking a random subset of the top-k indices
    from a random branch and adding/subtracting random bytes within a
    limited range.

    Args:
        seed_file_numpy (np.ndarray): Np array version of the seed file bytes.
        ordered_indices (np.ndarray): Numpy array containing rows of critical
            locations, ordered by respective gradient component magnitudes.
        mutations_dir (str): Directory to write mutated files to.
        seed_file_name (str): Raw basename (no extension) of the seed file
            to be mutated.
        num_mutations (int): Number of mutated files to save.
        neighborhood_max_width (int): Maximum number of bytes
            (in either direction) to mutate around a critical location.
        arith_min (int): Smallest possible additive mutation to any
            critical byte.
        arith_max (int): Largest possible additive mutation to any critical byte
            (See line 123 in constants.py for information on defaults).


    Returns:
        N/A (mutated files are saved under
            generated/[generation-name]/mutations)
    """
  for mutation_num in range(num_mutations):
    seed_file_copy = seed_file_numpy.copy()
    branch_idx = np.random.randint(0, high=len(ordered_indices))
    which_indices = np.random.choice(
        ordered_indices[branch_idx],
        size=np.random.randint(1, high=len(ordered_indices[branch_idx])),
        replace=False)

    # Picks randomly-sized neighborhoods around each critical location.
    if neighborhood_max_width > 0:
      widths = np.random.randint(
          low=0, high=neighborhood_max_width + 1, size=which_indices.shape)
      which_indices = np.concatenate([
          list(
              range(
                  max(0, crit_idx - width),
                  min(crit_idx + width + 1, len(seed_file_copy))))
          for (crit_idx, width) in zip(which_indices, widths)
      ])

    # New byte values should be uniform over [0, 255].
    change_by = np.random.randint(
        arith_min, arith_max + 1, size=len(which_indices))
    seed_file_copy[which_indices] = (
        seed_file_copy[which_indices] + change_by) % constants.MAX_BYTE_VAL

    save_path = (
        os.path.join(mutations_dir,
                     constants.GENERIC_MUTATION_PREFIX + seed_file_name).format(
                         branch_idx=branch_idx, num=mutation_num))
    write_numpy_to_bytefile(seed_file_copy, save_path)


def mutate_one_simple_random(seed_file_numpy, ordered_indices, mutations_dir,
                             seed_file_name, num_mutations):
  """
    Generates mutations by picking a random subset of the top-k indices
    from a random branch and adding/subtracting random amounts to each
    critical byte.

    Args:
        seed_file_numpy (np.ndarray): Np array version of the seed file bytes.
        ordered_indices (np.ndarray): Numpy array containing rows of critical
            locations, ordered by respective gradient component magnitudes.
        mutations_dir (str): Directory to write mutated files to.
        seed_file_name (str): Raw basename (no extension) of the seed file
            to be mutated.
        num_mutations (int): Number of mutated files to save.


    Returns:
        N/A (mutated files are saved under
            generated/[generation-name]/mutations)
    """
  for mutation_num in range(num_mutations):
    seed_file_copy = seed_file_numpy.copy()
    branch_idx = np.random.randint(0, high=len(ordered_indices))
    which_indices = np.random.choice(
        ordered_indices[branch_idx],
        size=np.random.randint(0, high=len(ordered_indices[branch_idx])),
        replace=False)

    # New byte values should be uniform over [0, 255].
    change_by = np.random.randint(
        constants.MIN_BYTE_VAL, constants.MAX_BYTE_VAL, size=len(which_indices))
    seed_file_copy[which_indices] = (
        seed_file_copy[which_indices] + change_by) % constants.MAX_BYTE_VAL

    save_path = (
        os.path.join(mutations_dir,
                     constants.GENERIC_MUTATION_PREFIX + seed_file_name).format(
                         branch_idx=branch_idx, num=mutation_num))
    write_numpy_to_bytefile(seed_file_copy, save_path)


def mutation_gen_loop(start_idx,
                      end_idx,
                      ordered_index_file_paths,
                      seed_file_paths,
                      seed_file_mapping,
                      mutations_dir,
                      input_length_mapping,
                      args,
                      first=False):
  """
    Iterates through each critical index file and mutates the original inputs.

    Args:
        start_idx (int): Process files beginning at this index
            (for multithreading; inclusive).
        end_idx (int): Process files ending at this index
            (for multithreading; exclusive).
        ordered_index_file_paths (list): List of critical location file paths.
        seed_file_paths (list): List of full paths to all seed files.
        seed_file_mapping (dict): Maps critical location file to seed file.
        mutations_dir (str): Where mutated files get saved.
        input_length_mapping (dict): Dictionary of input paths to
            input byte lengths.
        args (argparse.Namespace): Arguments passed into
            `get_gen_mutations_args()` (opts.py).
        first (bool): Whether to display the tqdm progress bar.

    Returns:
        N/A
    """
  this_thread_file_paths = ordered_index_file_paths[start_idx:end_idx]
  iterator = tqdm.tqdm(
      this_thread_file_paths) if first else this_thread_file_paths
  for gradient_file_path in iterator:
    seed_file_name = os.path.basename(gradient_file_path)

    if seed_file_name == constants.METADATA_FILENAME:
      continue

    seed_file_length = int(input_length_mapping[seed_file_name])
    seed_file_path = seed_file_paths[seed_file_mapping[seed_file_name]]
    seed_file_numpy = libfuzzer_to_numpy.convert_input_to_numpy(
        seed_file_path)[:seed_file_length]
    ordered_indices = np.load(gradient_file_path).astype(np.int32)
    seed_file_name = seed_file_name[:seed_file_name.rfind('.npy')]

    if args.mutation_gen_method == constants.NEUZZ_MUTATION:
      mutate_one_like_neuzz(seed_file_numpy, ordered_indices, mutations_dir,
                            seed_file_name)

    elif args.mutation_gen_method == constants.SIMPLE_RANDOM:
      mutate_one_simple_random(seed_file_numpy, ordered_indices, mutations_dir,
                               seed_file_name, args.num_mutations)

    elif args.mutation_gen_method == constants.LIMITED_NEIGHBORHOOD:
      mutate_one_limited_neighborhood(
          seed_file_numpy, ordered_indices, mutations_dir, seed_file_name,
          args.num_mutations, args.neighborhood_max_width, args.arith_min,
          args.arith_max)

    # Also save a copy of the original.
    orig_save_path = (
        os.path.join(mutations_dir, constants.ORIGINAL_PREFIX + seed_file_name))
    write_numpy_to_bytefile(seed_file_numpy, orig_save_path)


def generate_mutations(args, gradient_metadata, gradients_dir, mutations_dir):
  """
    Generates mutations from input files as specified by
        metadata['path_to_seeds'].

    Args:
        args (argparse.Namespace): Arguments as specified by
            `get_gen_mutations_args()` in opts.py.
        gradient_metadata (dict): Metadata as constructed in
            gradient_gen_critical_locs.py. See documentation for
            `generate_all_critical_locs()`.
        gradients_dir (str): Directory from which to pull
            critical locations files.
        mutations_dir (str): Directory to write mutated files to.

    Returns:
        N/A
    """
  seed_file_paths = list(
      glob.glob(os.path.join(gradient_metadata['path_to_seeds'], '*')))
  seed_file_mapping = {}
  for idx, seed_path in enumerate(seed_file_paths):
    seed_file_mapping[os.path.basename(seed_path)] = idx
  input_length_mapping = json.load(open(args.path_to_lengths, 'r'))

  ordered_index_file_paths = list(glob.glob(os.path.join(gradients_dir, '*')))

  # Standard multithreading to speed up mutation generation.
  num_threads = os.cpu_count()
  workers = [None] * num_threads
  num_inputs_per_worker = math.ceil(len(ordered_index_file_paths) / num_threads)

  for worker_idx, _ in enumerate(workers):
    start_idx = worker_idx * num_inputs_per_worker
    end_idx = min(
        len(ordered_index_file_paths), (worker_idx + 1) * num_inputs_per_worker)
    workers[worker_idx] = threading.Thread(
        target=mutation_gen_loop,
        args=(start_idx, end_idx, ordered_index_file_paths, seed_file_paths,
              seed_file_mapping, mutations_dir, input_length_mapping, args,
              worker_idx == 0))
    workers[worker_idx].start()

  for worker in workers:
    worker.join()


def main():
  """
    Uses generated critical location data from gradient_gen_critical_locs.py
    to perform mutations and save mutated files.

    Args:
        N/A

    Returns:
        N/A (generated files saved to generated/[generation-name]/mutations)
    """
  args = opts.get_gen_mutations_args()

  # Setting up directory tree and reading metadata in.
  generated_dir = os.path.join(constants.GENERATED_DIR, args.generation_name)
  if not os.path.isdir(generated_dir):
    print(('Error: Cannot locate directory {}. ' +
           '(Did you run gradient_gen_critical_locs.py first?)')
          .format(generated_dir))
    sys.exit()
  gradients_dir = os.path.join(generated_dir, constants.GRADIENTS_DIR)
  mutations_dir = os.path.join(generated_dir, constants.MUTATIONS_DIR,
                               args.mutation_name)
  if os.path.isdir(mutations_dir):
    print(('Error: {} already exists! (Did you already run gen_mutations.py ' +
           'on {} with name {}?)').format(mutations_dir, args.generation_name,
                                          args.mutation_name))
    sys.exit()
  os.makedirs(mutations_dir)
  print('Writing mutated inputs to {}'.format(mutations_dir))

  # Gets metadata from critical location generation.
  metadata_filepath = os.path.join(gradients_dir, constants.METADATA_FILENAME)
  gradient_metadata = json.load(open(metadata_filepath, 'r'))

  if opts.check_gen_mutations_args(args):
    generate_mutations(args, gradient_metadata, gradients_dir, mutations_dir)


if __name__ == '__main__':
  main()
